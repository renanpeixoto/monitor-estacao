<!DOCTYPE html>
<html lang="pt-br">
<head>
  <meta charset="UTF-8">
  <title>Resumo da Estação</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <style>
    :root { font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif; }
    body { margin: 0; background: #f3f4f6; }
    header { background: #0f766e; color: #fff; padding: 1rem 1.2rem; }
    main { padding: 1.2rem; max-width: 1200px; margin: 0 auto; }

    .controls {
      display: flex;
      gap: .75rem;
      flex-wrap: wrap;
      margin-bottom: 1rem;
      align-items: center;
    }
    input, button, select {
      padding: .35rem .6rem;
      font-size: .9rem;
    }
    button {
      background: #0f766e;
      color: #fff;
      border: none;
      border-radius: .25rem;
      cursor: pointer;
    }
    button:hover { background: #115e57; }
    .status { font-size: .8rem; color: #475569; }

    .cards {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
      gap: .75rem;
      margin-bottom: 1rem;
    }
    .card {
      background: #fff;
      border-radius: .5rem;
      padding: .75rem .9rem;
      box-shadow: 0 1px 3px rgba(15, 23, 42, .1);
    }
    .card-title {
      font-size: .7rem;
      color: #64748b;
      margin-bottom: .35rem;
      text-transform: uppercase;
    }
    .card-value { font-size: 1.3rem; font-weight: 600; }
    .card-sub { font-size: .7rem; color: #94a3b8; margin-top: .25rem; }

    .section {
      background: #fff;
      border-radius: .5rem;
      box-shadow: 0 1px 3px rgba(15,23,42,.1);
      padding: .75rem 1rem 1rem;
      margin-bottom: 1rem;
    }
    .section-title {
      display:flex;
      justify-content: space-between;
      align-items:center;
      margin-bottom: .5rem;
      font-weight: 600;
    }
    .section-title select {
      font-size: .8rem;
    }

    @media (max-width: 880px) {
      .controls { flex-direction: column; align-items: flex-start; }
    }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
</head>
<body>
  <header>
    <h1 style="margin:0;font-size:1.1rem;">Resumo da Estação</h1>
    <p style="margin:.2rem 0 0;font-size:.8rem;">Projeto ARCA • LAPMAR / UFPA • API: Railway • Dados: PostgreSQL</p>
  </header>

  <main>
    <div class="controls">
      <div>
        <label for="stationId">Estação:</label>
        <input type="number" id="stationId" value="1" min="1" style="width:4rem;">
      </div>
      <div>
        <label for="limit">Registros usados nas estatísticas:</label>
        <input type="number" id="limit" value="50" min="10" max="500" style="width:4.5rem;">
      </div>
      <button id="reloadBtn">Atualizar agora</button>
      <span id="status" class="status">Carregando...</span>
    </div>

    <!-- cards com último valor e média -->
    <div class="cards">
      <div class="card">
        <div class="card-title">Temperatura do ar (°C)</div>
        <div class="card-value" id="last-air-temp">—</div>
        <div class="card-sub" id="mean-air-temp">Média: —</div>
      </div>
      <div class="card">
        <div class="card-title">Umidade relativa (%)</div>
        <div class="card-value" id="last-air-humid">—</div>
        <div class="card-sub" id="mean-air-humid">Média: —</div>
      </div>
      <div class="card">
        <div class="card-title">Vento médio (m/s)</div>
        <div class="card-value" id="last-wind-mean">—</div>
        <div class="card-sub" id="mean-wind-mean">Média: —</div>
      </div>
      <div class="card">
        <div class="card-title">Direção do vento (°)</div>
        <div class="card-value" id="last-wind-dir">—</div>
        <div class="card-sub" id="mode-wind-dir">Moda (predom.): —</div>
      </div>
      <div class="card">
        <div class="card-title">Pressão atmosférica (hPa)</div>
        <div class="card-value" id="last-air-pressure">—</div>
        <div class="card-sub" id="mean-air-pressure">Média: —</div>
      </div>
      <div class="card">
        <div class="card-title">Temperatura da água (°C)</div>
        <div class="card-value" id="last-water-temp">—</div>
        <div class="card-sub" id="mean-water-temp">Média: —</div>
      </div>
      <div class="card">
        <div class="card-title">Nível de água (m)</div>
        <div class="card-value" id="last-water-level">—</div>
        <div class="card-sub" id="mean-water-level">Média: —</div>
      </div>
    </div>

    <!-- gráfico atmosfera -->
    <div class="section">
      <div class="section-title">
        <span>Série temporal — Atmosfera</span>
        <label style="font-weight:normal;font-size:.8rem;">
          Variável:
          <select id="atmoParam">
            <option value="air_temperature">Temp. ar (°C)</option>
            <option value="air_humid">Umidade (%)</option>
            <option value="wind_speed_mean">Vento médio (m/s)</option>
            <option value="air_pressure">Pressão (hPa)</option>
            <option value="wind_direction">Direção do vento (°)</option>
          </select>
        </label>
      </div>
      <small id="atmo-range" style="display:block;font-size:.75rem;color:#64748b;margin-bottom:.25rem;"></small>
      <canvas id="atmoChart" height="110"></canvas>
    </div>

    <!-- gráfico água -->
    <div class="section">
      <div class="section-title">
        <span>Série temporal — Água</span>
        <label style="font-weight:normal;font-size:.8rem;">
          Variável:
          <select id="waterParam">
            <option value="water_temperature">Temp. água (°C)</option>
            <option value="water_level">Nível de água (m)</option>
          </select>
        </label>
      </div>
      <small id="water-range" style="display:block;font-size:.75rem;color:#64748b;margin-bottom:.25rem;"></small>
      <canvas id="waterChart" height="110"></canvas>
    </div>
  </main>

  <script>
    const API_BASE = "https://apiestacao-production.up.railway.app";

    const statusEl = document.getElementById("status");
    const stationInput = document.getElementById("stationId");
    const limitInput = document.getElementById("limit");
    const btn = document.getElementById("reloadBtn");

    // cards – últimos valores
    const lastAirTempEl      = document.getElementById("last-air-temp");
    const lastAirHumidEl     = document.getElementById("last-air-humid");
    const lastWindMeanEl     = document.getElementById("last-wind-mean");
    const lastWindDirEl      = document.getElementById("last-wind-dir");
    const lastAirPressureEl  = document.getElementById("last-air-pressure");
    const lastWaterTempEl    = document.getElementById("last-water-temp");
    const lastWaterLevelEl   = document.getElementById("last-water-level");

    // cards – médias/moda
    const meanAirTempEl      = document.getElementById("mean-air-temp");
    const meanAirHumidEl     = document.getElementById("mean-air-humid");
    const meanWindMeanEl     = document.getElementById("mean-wind-mean");
    const modeWindDirEl      = document.getElementById("mode-wind-dir");
    const meanAirPressureEl  = document.getElementById("mean-air-pressure");
    const meanWaterTempEl    = document.getElementById("mean-water-temp");
    const meanWaterLevelEl   = document.getElementById("mean-water-level");

    const atmoRangeEl  = document.getElementById("atmo-range");
    const waterRangeEl = document.getElementById("water-range");

    const atmoParamSelect  = document.getElementById("atmoParam");
    const waterParamSelect = document.getElementById("waterParam");

    let latestData = [];
    let atmoChart  = null;
    let waterChart = null;

    function formatDateToBelem(iso) {
      if (!iso) return "";
      const date = new Date(iso);
      return date.toLocaleString("pt-BR", { timeZone: "America/Belem" });
    }

    function computeMean(data, field) {
      let sum = 0;
      let count = 0;
      for (const row of data) {
        const v = row[field];
        if (v !== null && v !== undefined) {
          sum += Number(v);
          count += 1;
        }
      }
      if (count === 0) return null;
      return sum / count;
    }

    function computeMode(data, field) {
      const freq = {};
      for (const row of data) {
        const v = row[field];
        if (v !== null && v !== undefined) {
          const key = String(Math.round(Number(v))); // arredonda p/ grau inteiro
          freq[key] = (freq[key] || 0) + 1;
        }
      }
      let bestKey = null;
      let bestCount = 0;
      for (const k in freq) {
        if (freq[k] > bestCount) {
          bestCount = freq[k];
          bestKey = k;
        }
      }
      return bestKey !== null ? Number(bestKey) : null;
    }

    function fmt(val, decimals = 2) {
      if (val === null || val === undefined || Number.isNaN(val)) return "—";
      return Number(val).toFixed(decimals);
    }

    async function loadData() {
      const stationId = stationInput.value || 1;
      const limit = limitInput.value || 50;
      statusEl.textContent = `Carregando últimos ${limit} registros da estação ${stationId}...`;

      try {
        const resp = await fetch(`${API_BASE}/latest?station_id=${stationId}&limit=${limit}`);
        if (!resp.ok) throw new Error("HTTP " + resp.status);
        const json = await resp.json();
        const data = json.data || [];
        latestData = data;

        if (data.length === 0) {
          statusEl.textContent = "Nenhum dado disponível para essa estação.";
          return;
        }

        // ordenar da mais antiga para a mais recente
        const sorted = [...data].sort((a, b) => new Date(a.date) - new Date(b.date));
        const first = sorted[0];
        const last  = sorted[sorted.length - 1];

        const rangeLabel = `${formatDateToBelem(first.date)} → ${formatDateToBelem(last.date)}`;
        atmoRangeEl.textContent  = rangeLabel;
        waterRangeEl.textContent = rangeLabel;

        // último registro (mais recente)
        const lastRow = last;

        // atualizar cards – últimos valores
        lastAirTempEl.textContent     = fmt(lastRow.air_temperature, 1);
        lastAirHumidEl.textContent    = fmt(lastRow.air_humid, 1);
        lastWindMeanEl.textContent    = fmt(lastRow.wind_speed_mean, 2);
        lastWindDirEl.textContent     = lastRow.wind_direction != null ? `${Math.round(lastRow.wind_direction)}°` : "—";
        lastAirPressureEl.textContent = fmt(lastRow.air_pressure, 1);
        lastWaterTempEl.textContent   = fmt(lastRow.water_temperature, 2);
        lastWaterLevelEl.textContent  = fmt(lastRow.water_level, 2);

        // médias / moda
        const meanAirTemp     = computeMean(sorted, "air_temperature");
        const meanAirHumid    = computeMean(sorted, "air_humid");
        const meanWindMean    = computeMean(sorted, "wind_speed_mean");
        const meanAirPressure = computeMean(sorted, "air_pressure");
        const meanWaterTemp   = computeMean(sorted, "water_temperature");
        const meanWaterLevel  = computeMean(sorted, "water_level");
        const modeWindDir     = computeMode(sorted, "wind_direction");

        meanAirTempEl.textContent     = `Média: ${fmt(meanAirTemp, 1)}`;
        meanAirHumidEl.textContent    = `Média: ${fmt(meanAirHumid, 1)}`;
        meanWindMeanEl.textContent    = `Média: ${fmt(meanWindMean, 2)}`;
        meanAirPressureEl.textContent = `Média: ${fmt(meanAirPressure, 1)}`;
        meanWaterTempEl.textContent   = `Média: ${fmt(meanWaterTemp, 2)}`;
        meanWaterLevelEl.textContent  = `Média: ${fmt(meanWaterLevel, 2)}`;
        modeWindDirEl.textContent     = modeWindDir != null ? `Moda (predom.): ${modeWindDir.toFixed(0)}°` : "Moda (predom.): —";

        // atualizar gráficos
        updateCharts(sorted);

        statusEl.textContent = `Dados atualizados. Usando ${sorted.length} registros da estação ${stationId}.`;
      } catch (err) {
        console.error(err);
        statusEl.textContent = "Erro ao carregar dados. Veja o console.";
      }
    }

    function buildSeries(sortedData, field) {
      const labels = sortedData.map(row => formatDateToBelem(row.date));
      const values = sortedData.map(row => {
        const v = row[field];
        return v == null ? null : Number(v);
      });
      return { labels, values };
    }

    function updateCharts(sortedData) {
      const atmoField  = atmoParamSelect.value;
      const waterField = waterParamSelect.value;

      const atmoSeries  = buildSeries(sortedData, atmoField);
      const waterSeries = buildSeries(sortedData, waterField);

      const atmoCtx  = document.getElementById("atmoChart").getContext("2d");
      const waterCtx = document.getElementById("waterChart").getContext("2d");

      // rótulos bonitos
      const labelsPretty = {
        air_temperature: "Temperatura do ar (°C)",
        air_humid: "Umidade relativa (%)",
        wind_speed_mean: "Vento médio (m/s)",
        air_pressure: "Pressão atmosférica (hPa)",
        wind_direction: "Direção do vento (°)",
        water_temperature: "Temperatura da água (°C)",
        water_level: "Nível de água (m)",
      };

      if (atmoChart) {
        atmoChart.data.labels = atmoSeries.labels;
        atmoChart.data.datasets[0].data = atmoSeries.values;
        atmoChart.data.datasets[0].label = labelsPretty[atmoField] || atmoField;
        atmoChart.update();
      } else {
        atmoChart = new Chart(atmoCtx, {
          type: "line",
          data: {
            labels: atmoSeries.labels,
            datasets: [{
              label: labelsPretty[atmoField] || atmoField,
              data: atmoSeries.values,
              borderColor: "rgba(15,118,110,1)",
              backgroundColor: "rgba(15,118,110,0.15)",
              tension: 0.2,
              spanGaps: true,
              pointRadius: 2
            }]
          },
          options: {
            responsive: true,
            interaction: { mode: 'index', intersect: false },
            plugins: { legend: { display: true } },
            scales: {
              x: { ticks: { maxTicksLimit: 8 } },
              y: { beginAtZero: false }
            }
          }
        });
      }

      if (waterChart) {
        waterChart.data.labels = waterSeries.labels;
        waterChart.data.datasets[0].data = waterSeries.values;
        waterChart.data.datasets[0].label = labelsPretty[waterField] || waterField;
        waterChart.update();
      } else {
        waterChart = new Chart(waterCtx, {
          type: "line",
          data: {
            labels: waterSeries.labels,
            datasets: [{
              label: labelsPretty[waterField] || waterField,
              data: waterSeries.values,
              borderColor: "rgba(59,130,246,1)",
              backgroundColor: "rgba(59,130,246,0.15)",
              tension: 0.2,
              spanGaps: true,
              pointRadius: 2
            }]
          },
          options: {
            responsive: true,
            interaction: { mode: 'index', intersect: false },
            plugins: { legend: { display: true } },
            scales: {
              x: { ticks: { maxTicksLimit: 8 } },
              y: { beginAtZero: false }
            }
          }
        });
      }
    }

    btn.addEventListener("click", loadData);
    atmoParamSelect.addEventListener("change", () => {
      if (latestData.length > 0) updateCharts([...latestData].sort((a,b)=>new Date(a.date)-new Date(b.date)));
    });
    waterParamSelect.addEventListener("change", () => {
      if (latestData.length > 0) updateCharts([...latestData].sort((a,b)=>new Date(a.date)-new Date(b.date)));
    });

    // primeira carga + atualização periódica
    loadData();
    setInterval(loadData, 60000);
  </script>
</body>
</html>



